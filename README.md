[![](https://www.paypalobjects.com/en_US/i/btn/btn_donateCC_LG.gif)](https://www.paypal.com/donate/?hosted_button_id=58F9TDDRBND4L)

# AWS Terraform Helm Microservices PoC for Devops
This PoC shows how to use Terraform to host TLS microservices (or many) in Amazon Elastic Kubernetes Service (Amazon EKS) deployed with Helm charts. The structure of the project is below and it is the third of three cloud projects (GCP, AZ, AWS) that show how to manage microservices hosted in different cloud providers.

# Preconditions
## Create credentials, export them and use them when configuring aws 
```
aws configure
```
## Install aws-cli (using OSX here)
```
curl "https://awscli.amazonaws.com/AWSCLIV2.pkg" -o "AWSCLIV2.pkg"
sudo installer -pkg AWSCLIV2.pkg -target /
aws --version
```
## Install
```
brew tap weaveworks/tap
brew install weaveworks/tap/eksctl
```

## Terraform

- Confirm that you are using the expected credentials:
```
aws sts get-caller-identity
```
- Create the S3 bucket to persist terraform
```
aws s3api create-bucket --bucket ms-terraform-state1 --region eu-north-1 --create-bucket-configuration LocationConstraint=eu-north-1
```
- A Dynamo table must be created for terraform state locking
```
aws dynamodb create-table \
    --table-name ms-terraform-state1 \
    --attribute-definitions AttributeName=LockID,AttributeType=S \
    --key-schema AttributeName=LockID,KeyType=HASH \
    --billing-mode PAY_PER_REQUEST \
    --region eu-north-1
```
- Ensure that the bucket was created and is accessible under the identity specified by the credentials file:
```
aws s3 ls
```

- List all terraform files and their content
```
find ./ -type f -name "*.tf" -not -path '*.terraform*' -exec sh -c 'echo "File: {}"; cat {}' \;
```
- List all terraform configuration file names and specific content if found in any of them
find ./ -type f -name "*.tf" -not -path '*.terraform*' -exec sh -c 'echo "File: {}"; cat {}' \; | grep -E "\.tf|provider.*kubernetes"
```
- Set terraform log level as needed
```
export TF_LOG=INFO
export TF_LOG=TRACE
```

- Create and apply terraform plan
```
cd terraform
export TF_LOG=INFO; export KUBE_CONFIG_PATH=~/.kube/config && terraform init && terraform validate && terraform plan -out=tfplan && terraform apply "tfplan"
```

## kubernetes access
- Check cluster status:
```
aws eks --region eu-north-1 list-clusters
aws eks --region eu-north-1 describe-cluster --name cluster1
aws eks --region eu-north-1 list-nodegroups --cluster-name cluster1 
```
- Authorize kubectl to access the cluster 
```
aws eks --region eu-north-1 update-kubeconfig --name cluster1
```
- Add the current AWS IAM account an IAM access entry with permissions to access the cluster by going to the cluster from the AWS console, access tab, create access entry, select the ARN of your principal (you can search for it in the dropdown or see it from CLI with command aws sts get-caller-identity), next, add access policy, select AmazonEKSAdminPolicy, next, create and go back to the access tab, click on the access entry you added for your user ARN, add access policy, select AmazonEKSClusterAdminPolicy.
- Find out users and roles with access to the kubernetes cluster
```
kubectl describe configmap -n kube-system aws-auth 
``` 
- Install thei AWS Load Balancer controller
```
./deploy-aws-load-balancer-controller.sh cluster1
```
- Authenticate docker client to work with AWS ECR
```
AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query "Account" --output text)
AWS_REGION=$(aws configure get region)
aws ecr get-login-password --region $AWS_REGION | docker login --username AWS --password-stdin $AWS_ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com
```
- Deploy via helm a microservice named "microservice#" where # is the major version which keeps support for that particular release which usees the TLS certificate for the domain, previously generated by terraform. The api-ingress.yaml will create an ALB if it does not exist. It is this ALB which we need to use to create the A record for the domain in Route53.
```
./deploy.sh ./deploy.sh default test2.nestorurquiza.com microservice1 1.0.0
```
- Extract the ALB address from the ingress. If you ever remove all ingresses for the same group , then you must repeat this step
```
GROUP_NAME=$(grep 'alb.ingress.kubernetes.io/group.name' helm/templates/api-ingress.yaml | awk -F'"' '{print $2}'); kubectl get ingress -A -o json | jq -r --arg GROUP_NAME "$GROUP_NAME" '.items[] | select(.metadata.annotations."alb.ingress.kubernetes.io/group.name"==$GROUP_NAME).status.loadBalancer.ingress[].hostname' | head -1
```
- Use the ALB address to create the A record for the domain:
```
./add-a-record-for-alb.sh <ALB_ADDRESS> test2.nestorurquiza.com nestorurquiza.com
```
- List all yaml files (mostly used from helm)
```
find ./ -type f -name "*.yaml" -exec sh -c 'echo "File: {}"; cat {}' \;
```
- Test the app responds on port 8080 in the deployed pods
```
kubectl exec -ti $(kubectl get pods | grep -o 'microservice[^ ]*' | head -1) -- curl localhost:8080
```
- Test the app responds on port 80 in the deployed service
```
kubectl port-forward svc/microservice1-1 8080:80 & sleep 5 && curl localhost:8080
```
- Test the app from the ALB external endpoint
```
export EXPECTED_API_KEY='2f5ae96c-b558-4c7b-a590-a501ae1c3f6c' && export HOST=test2.nestorurquiza.com && curl -kX POST -H "X-Parse-REST-API-Key: ${EXPECTED_API_KEY}" -H "Content-Type: application/json" -d '{ "message": "This is a test", "to": "Juan Perez", "from": "Rita Asturia", "timeToLifeSec": 45 }' http://${HOST}/api/microservice1/v1/DevOps
```
 
 
